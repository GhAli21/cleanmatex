# Project Backend ‚Äî AI System Prompt (NestJS + Supabase, No Prisma)

## 0. Purpose

These rules govern AI-generated backend code for this Project services when using:

- **NestJS** for API and orchestration
- **Supabase Postgres** as the primary database
- **@supabase/supabase-js** + generated `Database` types
- **No Prisma ORM**

If user instructions conflict, prefer these rules unless the user explicitly overrides them and acknowledges the deviation.

---

## 1. Core Backend Architecture Rules (MUST)

1. Use **NestJS modular architecture**:
   - `*.module.ts`, `*.controller.ts`, `*.service.ts`, `dto/`, and optional `entities/`.
2. All external input/output MUST be defined via **DTOs + ValidationPipe**.
3. **Supabase** is the primary persistence layer, accessed via a **typed data-access layer**:
   - No direct SQL in controllers.
   - No inline supabase-js calls in controllers.
4. **OpenAPI (Swagger) DTOs are the public contract**, not the Supabase schema.
5. Business logic lives in **services**, not controllers.
6. Use **strict TypeScript** ‚Äî no `any` in public-facing or core logic.
7. All mutation endpoints must be **retry-aware** and, where practical, **idempotent**.

---

## 2. Module & Layer Structure

Example feature layout:

```txt
src/
  modules/
    billing/
      billing.module.ts
      billing.controller.ts
      billing.service.ts
      billing.repository.ts      // Supabase data-access (recommended)
      dto/
        create-billing.dto.ts
        update-billing.dto.ts
      entities/
        billing.domain.ts        // domain models (optional but recommended)
```

Responsibilities:

- **Controller**: HTTP concerns, DTO binding, response formatting.
- **Service**: business logic, workflow orchestration, authorization, validation.
- **Repository**: Supabase queries, mapping Supabase rows ‚Üî domain models.
- **DTO**: input/output shapes for HTTP layer, with validation + OpenAPI decorators.
- **Domain model**: internal representation of core entities (optional but encouraged).

---

## 3. Supabase Types & Clients

### 3.1 Generated `Database` Type

Generate Supabase types using:

```bash
supabase gen types typescript --local > supabase/types.ts
```

File (recommended):

```txt
supabase/types.ts
```

Example:

```ts
// supabase/types.ts
export type Database = {
  // generated content
};
```

Do not edit this file manually.

### 3.2 Typed Supabase Client

Create a reusable, typed client for backend services:

```ts
// src/supabase/supabase-admin.client.ts
import { createClient } from "@supabase/supabase-js";
import type { Database } from "@/supabase/types";

export const supabaseAdmin = createClient<Database>(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  {
    auth: {
      persistSession: false,
    },
  }
);
```

Use the **service role key** only in backend, never in the frontend.

### 3.3 Table Types

Derive table-level types for repositories:

```ts
import type { Database } from "@/supabase/types";

export type HqUserRow = Database["public"]["Tables"]["hq_users"]["Row"];
export type HqUserInsert = Database["public"]["Tables"]["hq_users"]["Insert"];
export type HqUserUpdate = Database["public"]["Tables"]["hq_users"]["Update"];
```

These types are **DB contracts**, not DTOs.

---

## 4. Repository Pattern (Supabase Data Access)

Every feature that reads/writes the DB should have a repository (or set of repositories) wrapping supabase-js.

Example:

```ts
// src/modules/hq-users/hq-users.repository.ts
import { Injectable } from "@nestjs/common";
import { supabaseAdmin } from "@/supabase/supabase-admin.client";
import type { HqUserRow, HqUserInsert, HqUserUpdate } from "./hq-users.types";

@Injectable()
export class HqUsersRepository {
  async findById(id: string): Promise<HqUserRow | null> {
    const { data, error } = await supabaseAdmin
      .from("hq_users")
      .select("*")
      .eq("id", id)
      .maybeSingle();

    if (error) throw error;
    return data;
  }

  async create(payload: HqUserInsert): Promise<HqUserRow> {
    const { data, error } = await supabaseAdmin
      .from("hq_users")
      .insert(payload)
      .select("*")
      .single();

    if (error) throw error;
    return data;
  }

  async update(id: string, payload: HqUserUpdate): Promise<HqUserRow> {
    const { data, error } = await supabaseAdmin
      .from("hq_users")
      .update(payload)
      .eq("id", id)
      .select("*")
      .single();

    if (error) throw error;
    return data;
  }
}
```

Rules:

- All Supabase calls are centralized in repositories.
- Controllers MUST NOT call `supabaseAdmin` directly.

---

## 5. Domain Models & Mapping

### 5.1 Domain Models

Define internal domain models instead of reusing raw Supabase rows:

```ts
// src/modules/hq-users/hq-users.domain.ts
export interface HqUser {
  id: string;
  email: string;
  fullName: string;
  isActive: boolean;
}
```

### 5.2 Mapping Supabase Rows ‚Üí Domain

```ts
// src/modules/hq-users/hq-users.mapper.ts
import type { HqUserRow } from "./hq-users.types";
import type { HqUser } from "./hq-users.domain";

export function mapHqUserRowToDomain(row: HqUserRow): HqUser {
  return {
    id: row.id,
    email: row.email,
    fullName: row.full_name,
    isActive: row.is_active ?? true,
  };
}
```

Repositories return `HqUserRow`, services map those rows into `HqUser`, then controllers map `HqUser` into DTOs if needed.

### 5.3 Source-of-Truth Priority

If there is a conflict between:

1. DTOs / OpenAPI models
2. Domain models
3. Supabase `Database` types (`Row`, `Insert`, `Update`)

The priority is:

1. DTOs / OpenAPI (public contract)
2. Domain models / business logic
3. Supabase DB schema (implementation detail)

Supabase schema supports the contract, it does not define it.

---

## 6. DTOs, Validation & OpenAPI

### 6.1 DTO Rules

- DTOs live under `modules/<feature>/dto/`.
- DTOs MUST use `class-validator` decorators.
- DTOs SHOULD use `@nestjs/swagger` decorators for OpenAPI where appropriate.

Example:

```ts
// src/modules/billing/dto/create-billing.dto.ts
import { ApiProperty } from "@nestjs/swagger";
import {
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsPositive,
  IsString,
} from "class-validator";

export class CreateBillingDto {
  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  name: string;

  @ApiProperty()
  @IsNumber()
  @IsPositive()
  amount: number;

  @ApiProperty({ required: false })
  @IsOptional()
  @IsString()
  description?: string;
}
```

### 6.2 ValidationPipe

- Global `ValidationPipe` MUST be enabled with recommended options:
  - `whitelist: true`
  - `forbidNonWhitelisted: true`
  - `transform: true` (if needed)

### 6.3 OpenAPI

- Controllers MUST be annotated for Swagger:

```ts
@ApiTags('billing')
@Controller('billing')
export class BillingController { ... }
```

- DTOs form the OpenAPI schema definitions.
- The generated OpenAPI spec is the **canonical contract** for frontend and external clients.

---

## 7. Services & Business Logic

Services encapsulate business logic and orchestration:

```ts
// src/modules/billing/billing.service.ts
import { Injectable } from "@nestjs/common";
import { BillingRepository } from "./billing.repository";
import type { CreateBillingDto } from "./dto/create-billing.dto";
import { mapBillingRowToDomain } from "./billing.mapper";

@Injectable()
export class BillingService {
  constructor(private readonly repo: BillingRepository) {}

  async createBilling(tenantId: string, dto: CreateBillingDto) {
    // example: add tenant scoping, additional defaults, business rules
    const row = await this.repo.create({
      tenant_org_id: tenantId,
      name: dto.name,
      amount: dto.amount,
      description: dto.description ?? null,
    });

    return mapBillingRowToDomain(row);
  }
}
```

Rules:

- All tenant scoping, authorization checks, and business validations live here.
- Services can call multiple repositories and external services.

### 7.1 Tenant Context Management (CRITICAL)

**üö® MANDATORY: Use Centralized Tenant Context**

**For Next.js Services (web-admin):**

1. **ALWAYS import from centralized location:**

   ```typescript
   // ‚úÖ CORRECT
   import {
     getTenantIdFromSession,
     withTenantContext,
   } from "@/lib/db/tenant-context";

   // ‚ùå WRONG - Never create duplicate implementations
   async function getTenantIdFromSession(): Promise<string> {
     // This violates the rule!
   }
   ```

2. **For Prisma services:**

   - Wrap all Prisma queries on `org_*` tables with `withTenantContext()`
   - Middleware automatically adds `tenant_org_id` to queries
   - Example:
     ```typescript
     export async function createInvoice(input: CreateInvoiceInput) {
       const tenantId = await getTenantIdFromSession();
       if (!tenantId) throw new Error('Unauthorized');

       return withTenantContext(tenantId, async () => {
         // Middleware adds tenant_org_id automatically
         return await prisma.org_invoice_mst.create({ ... });
       });
     }
     ```

3. **For Supabase services:**
   - Use centralized `getTenantIdFromSession()` to get tenant ID
   - Explicitly add `.eq('tenant_org_id', tenantId)` to all queries
   - Example:
     ```typescript
     export async function getCustomers() {
       const tenantId = await getTenantIdFromSession();
       const { data } = await supabase
         .from("org_customers_mst")
         .select("*")
         .eq("tenant_org_id", tenantId); // Required
     }
     ```

**For NestJS Services (backend):**

- Tenant ID should be extracted from request context (via guards/interceptors)
- Pass tenant ID explicitly to service methods
- Services receive `tenantId` as parameter, not retrieved internally

**Code Review Checklist:**

- ‚úÖ No duplicate `getTenantIdFromSession()` implementations
- ‚úÖ All Prisma queries wrapped with `withTenantContext()` (for `org_*` tables)
- ‚úÖ All Supabase queries include `.eq('tenant_org_id', tenantId)`
- ‚úÖ All services import from `@/lib/db/tenant-context` (Next.js) or receive tenantId as parameter (NestJS)

---

## 8. Controllers

Controllers are thin:

```ts
// src/modules/billing/billing.controller.ts
import { Body, Controller, Post, Req, UseGuards } from "@nestjs/common";
import { ApiTags } from "@nestjs/swagger";
import { BillingService } from "./billing.service";
import { CreateBillingDto } from "./dto/create-billing.dto";
import { AuthGuard } from "@/auth/auth.guard";
import type { RequestWithTenant } from "@/auth/request-with-tenant.interface";

@ApiTags("billing")
@Controller("billing")
@UseGuards(AuthGuard)
export class BillingController {
  constructor(private readonly billingService: BillingService) {}

  @Post()
  async create(@Req() req: RequestWithTenant, @Body() dto: CreateBillingDto) {
    const tenantId = req.tenant.id;
    return this.billingService.createBilling(tenantId, dto);
  }
}
```

Rules:

- No Supabase calls inside controllers.
- No business logic beyond trivial mapping and calling services.

---

## 9. Auth, Tokens & Refresh

1. Auth logic lives in `auth` module(s).
2. Backends must support:
   - access tokens (short-lived),
   - refresh tokens (longer-lived).
3. Provide a stable refresh endpoint:

```http
POST /auth/refresh
Body: { "refreshToken": "<token>" }
Response: {
  "accessToken": "<token>",
  "expiresIn": number,
  "refreshToken"?: "<newRefreshToken>"
}
```

4. Errors for auth endpoints must use a predictable JSON shape so frontend clients can distinguish:
   - Invalid credentials,
   - Expired token,
   - Insufficient permissions.

---

## 10. Error Handling, Logging & Retry-Safety

1. Normalize errors using Nest `HttpException` and/or global exception filters.
2. Ensure you have a consistent error payload format:
   - `code`, `message`, `details?`, `traceId?`.
3. Log unexpected errors with structured logging (logger or external service).
4. Because frontend clients may retry failed requests:
   - Mutation endpoints should be **idempotent or retry-safe** where practical.
   - Use idempotency keys, unique constraints, or pre-existence checks to avoid duplicate side effects.

Pattern:

```ts
async createOrder(dto: CreateOrderDto, idempotencyKey: string) {
  const existing = await this.ordersRepository.findByIdempotencyKey(idempotencyKey)
  if (existing) return existing

  return this.ordersRepository.create({ ...dto, idempotency_key: idempotencyKey })
}
```

---

## 11. Developer Experience & Linting

1. Enforce ESLint rules to:
   - Disallow `any` in core layers,
   - Prevent circular dependencies,
   - Enforce module boundaries.
2. Use Prettier for consistent formatting.
3. Common patterns (pagination, filtering, auditing, multi-tenant scoping) should be extracted into shared utilities/services.
4. Re-usable patterns for Supabase queries (e.g., pagination helpers) must live in:
   - `src/supabase/` or `src/shared/persistence/`.

---

## 12. DO / DO NOT Summary for AI Assistants

### ‚úÖ DO

- Use NestJS modules/controllers/services/repositories for all features.
- Use Supabase `Database` types only in:
  - Supabase client typing,
  - Repositories,
  - Mapping layers.
- Map:
  - `Row` ‚Üí domain model ‚Üí DTO.
- Keep DTOs and OpenAPI as the public contract.
- Make mutation endpoints retry-safe where practical.

### ‚ùå DO NOT

- Do not:
  - Call `supabaseAdmin` directly from controllers.
  - Expose `Database['...']['Row']` in controller responses.
  - Use `Row` types as DTOs or form types.
  - Treat Supabase schema as the frontend contract.
  - Mix business logic into controllers.

---

## 13. Priority Rules for AI

When generating backend code for this Project:

1. ALWAYS:
   - Respect the NestJS module/controller/service/repository structure.
   - Use DTOs + ValidationPipe.
   - Use typed Supabase clients and repositories, not inline queries.
   - Map Supabase rows into domain/DTO models before returning.
2. PREFER:
   - Extending existing repositories/services over creating ad-hoc data access.
   - Reusing common utilities for pagination, filtering, and logging.
   - Pagination Always should be Server-Side Pagination (API-Driven)
3. ONLY DEVIATE if:
   - The user explicitly asks for a simplified example or POC-style snippet,
   - You clearly localize the deviation and do not treat it as a new standard.
