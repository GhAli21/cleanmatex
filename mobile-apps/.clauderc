# Flutter Mobile Apps - Claude Code Configuration
# Location: mobile-apps/.clauderc

context: "Flutter Mobile Applications for CleanMateX Laundry SaaS"

# Important Files
important_files:
  - "lib/main.dart"                     # Entry point
  - "lib/core/providers.dart"           # Riverpod providers
  - "lib/core/api_client.dart"          # HTTP client (Dio)
  - "lib/core/router.dart"              # Navigation (go_router)
  - "pubspec.yaml"                      # Dependencies

# Project Structure
structure:
  features: "lib/features/{feature}/"   # Feature-first organization
  core: "lib/core/"                     # Shared utilities, config
  shared: "lib/shared/"                 # Shared widgets, theme
  models: "lib/models/"                 # Data models
  l10n: "lib/l10n/"                     # Localization files

# State Management
state_management: "Riverpod"

# Key Packages
packages:
  - "flutter_riverpod: ^2.4.0"         # State management
  - "go_router: ^13.0.0"                # Navigation
  - "dio: ^5.4.0"                       # HTTP client
  - "hive: ^2.2.3"                      # Local storage
  - "flutter_localizations"             # i18n
  - "freezed: ^2.4.6"                   # Code generation
  - "json_annotation: ^4.8.1"           # JSON serialization

# Coding Standards
standards:
  - "Use const constructors wherever possible"
  - "Avoid StatefulWidget unless absolutely needed"
  - "Use ConsumerWidget with Riverpod"
  - "Extract widgets if nesting > 3 levels deep"
  - "Use meaningful variable names (no abbreviations)"
  - "Add comments for complex logic"
  - "Follow Effective Dart guidelines"

# Widget Guidelines
widgets:
  separation: "Separate UI from business logic"
  builders: "Use ListView.builder for lists"
  states: "Always handle loading, error, and empty states"
  rtl: "Support RTL direction for Arabic"
  example: |
    class OrderListScreen extends ConsumerWidget {
      @override
      Widget build(BuildContext context, WidgetRef ref) {
        final ordersAsync = ref.watch(ordersProvider);
        
        return Scaffold(
          appBar: AppBar(title: Text('Orders')),
          body: ordersAsync.when(
            data: (orders) => ListView.builder(
              itemCount: orders.length,
              itemBuilder: (context, index) => OrderCard(orders[index]),
            ),
            loading: () => CircularProgressIndicator(),
            error: (error, stack) => ErrorWidget(error),
          ),
        );
      }
    }

# Riverpod Patterns
riverpod:
  provider: |
    final ordersProvider = FutureProvider<List<Order>>((ref) async {
      final api = ref.watch(apiClientProvider);
      return api.getOrders();
    });
  
  state_notifier: |
    class OrdersNotifier extends StateNotifier<AsyncValue<List<Order>>> {
      OrdersNotifier(this._api) : super(AsyncValue.loading()) {
        loadOrders();
      }
      
      final ApiClient _api;
      
      Future<void> loadOrders() async {
        state = AsyncValue.loading();
        state = await AsyncValue.guard(() => _api.getOrders());
      }
    }

# API Integration (Dio)
api:
  setup: |
    final dio = Dio(BaseOptions(
      baseUrl: 'https://api.example.com',
      headers: {'Content-Type': 'application/json'},
    ));
    
    // Add interceptor for auth
    dio.interceptors.add(AuthInterceptor());
  
  usage: |
    try {
      final response = await dio.get('/orders');
      return response.data;
    } on DioException catch (e) {
      // Handle error
      throw ApiException.fromDioError(e);
    }

# Navigation (go_router)
navigation:
  setup: |
    final router = GoRouter(
      routes: [
        GoRoute(
          path: '/',
          builder: (context, state) => HomeScreen(),
        ),
        GoRoute(
          path: '/orders/:id',
          builder: (context, state) {
            final id = state.pathParameters['id']!;
            return OrderDetailScreen(orderId: id);
          },
        ),
      ],
    );
  
  usage: |
    // Navigate
    context.go('/orders/123');
    context.push('/orders/new');
    
    // Go back
    context.pop();

# Forms & Validation
forms:
  controller: "Use TextEditingController"
  validation: "Use Form widget with validators"
  example: |
    final _formKey = GlobalKey<FormState>();
    final _nameController = TextEditingController();
    
    TextFormField(
      controller: _nameController,
      validator: (value) {
        if (value == null || value.isEmpty) {
          return 'Please enter name';
        }
        return null;
      },
    );
    
    // Submit
    if (_formKey.currentState!.validate()) {
      // Process data
    }

# Localization (i18n)
localization:
  setup: |
    MaterialApp(
      localizationsDelegates: [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: [
        Locale('en', ''),
        Locale('ar', ''),
      ],
    );
  
  usage: |
    Text(AppLocalizations.of(context)!.orders)

# Theme & Styling
theme:
  setup: |
    ThemeData(
      colorScheme: ColorScheme.fromSeed(
        seedColor: Colors.blue,
        brightness: Brightness.light,
      ),
      useMaterial3: true,
    );
  
  spacing: "Use SizedBox for spacing (8, 16, 24, 32)"
  padding: "Use EdgeInsets.all() or EdgeInsets.symmetric()"

# Testing
testing:
  unit: "flutter test"
  widget: |
    testWidgets('renders order list', (tester) async {
      await tester.pumpWidget(MyApp());
      expect(find.text('Orders'), findsOneWidget);
    });
  
  integration: "flutter test integration_test"

# Performance
performance:
  - "Use const constructors"
  - "Implement shouldRebuild in CustomPainter"
  - "Use ListView.builder for long lists"
  - "Cache images with CachedNetworkImage"
  - "Avoid rebuilding entire tree"
  - "Use keys for list items"

# Common Patterns
patterns:
  loading_state: |
    if (isLoading) {
      return Center(child: CircularProgressIndicator());
    }
  
  error_state: |
    if (error != null) {
      return Center(child: Text('Error: $error'));
    }
  
  empty_state: |
    if (items.isEmpty) {
      return Center(child: Text('No items found'));
    }
  
  pull_to_refresh: |
    RefreshIndicator(
      onRefresh: () async {
        await ref.refresh(ordersProvider.future);
      },
      child: ListView(...),
    )

# Flutter Commands
commands:
  run: "flutter run"
  build_apk: "flutter build apk"
  build_ios: "flutter build ios"
  test: "flutter test"
  analyze: "flutter analyze"
  clean: "flutter clean"
  pub_get: "flutter pub get"

# Best Practices
best_practices:
  - "Always dispose controllers"
  - "Use async/await for async operations"
  - "Handle all error cases"
  - "Add loading indicators"
  - "Test on multiple screen sizes"
  - "Support both orientations"
  - "Add proper error messages"
  - "Implement proper back button handling"
